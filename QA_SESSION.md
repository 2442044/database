# 講義発表 Q&A 想定集 (完成版)
## 対象: データベースに精通した教授・技術者

---

### アーキテクチャ・技術選定

**Q1. なぜ Django ではなく Flask を採用したのですか？**
**A.** マイクロフレームワークである Flask は、必要最小限の機能から構成されており、今回のような独自の Vector DB 実装を含むカスタムアプリケーションの開発において、設計の自由度が高いため採用しました。DB層を SQLAlchemy 等の ORM に強制されず、生の SQL や独自のベクトル検索ロジックを柔軟に組み込める点がこのプロジェクトに適しています。

**実装コード (dvd_rental_app/app.py):**
```python
# Flaskアプリケーションの初期化
app = Flask(__name__)
# データベースファイルのパス設定（SQLiteを直接指定）
DATABASE = os.path.join(os.path.dirname(__file__), 'dvd_rental.db')
```

**Q2. データベースに SQLite を採用した積極的な理由は何ですか？**
**A.** 「個人経営の小規模店舗」という要件に対し、サーバー構築や運用コストがゼロに近い SQLite が最適解だからです。単一のファイルでデータベースが完結するため、バックアップがファイルコピーのみで済み、店舗スタッフでも管理可能な可搬性（Portability）を重視しました。

**Q3. コンテナ化（Docker）のメリットはこの規模のシステムでありますか？**
**A.** はい、あります。Python のバージョンや依存ライブラリ（特にベクトル計算用の `sentence-transformers` や `numpy`）の環境差異によるトラブルを完全に排除できます。開発環境と寸分違わぬ環境を店舗PC上に即座に構築・配布できる点は、完成されたシステムとしての信頼性を高めます。

---

### データベース設計 (RDB)

**Q4. データベースの正規化はどのレベルまで行っていますか？**
**A.** 第3正規形（3NF）まで厳密に適用しています。具体的には、`dvds` テーブルから `genres` を分離することで、ジャンル名への推移的関数従属を排除しました。これにより、ジャンル名の変更が一箇所で済み、データの不整合（更新時異常）を構造的に防いでいます。

**実装コード (dvd_rental_app/init_db.py):**
```python
# ジャンルを独立したテーブルとして定義 (正規化)
cursor.execute('''
CREATE TABLE IF NOT EXISTS genres (
    genre_id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL
)
''')
```

**Q5. 外部キー制約 (Foreign Key) によるデータ整合性の担保について教えてください。**
**A.** `dvds.genre_id`、`rentals.user_id`、`rentals.dvd_id` に外部キー制約を設定しています。これにより、存在しないジャンルの商品登録や、削除された会員によるレンタルといった「迷子データ」の発生をデータベースエンジンレベルで強制的に阻止しています。アプリケーションロジックに依存しない堅牢な設計です。

**実装コード (dvd_rental_app/init_db.py):**
```python
cursor.execute('''
CREATE TABLE IF NOT EXISTS dvds (
    dvd_id INTEGER PRIMARY KEY AUTOINCREMENT,
    ...
    genre_id INTEGER, -- 外部キー
    FOREIGN KEY (genre_id) REFERENCES genres (genre_id)
)
''')
```

**Q6. インデックス戦略について教えてください。**
**A.** 主キーのクラスター化インデックスに加え、`users` テーブルの `member_code` と `phone` に `UNIQUE` 制約を付与することで、一意性検索のためのインデックスを作成しています。これにより、会員コード読み取りや電話番号検索といった頻出クエリの応答速度を O(log N) に保ち、実用的なパフォーマンスを確保しています。

**実装コード (dvd_rental_app/init_db.py):**
```python
# UNIQUE制約によるインデックス作成
cursor.execute('''
CREATE TABLE IF NOT EXISTS users (
    ...
    member_code TEXT UNIQUE,
    phone TEXT UNIQUE NOT NULL,
    ...
)
''')
```

**Q7. 貸出・返却処理におけるトランザクション制御の詳細は？**
**A.** 貸出処理では、「レンタル履歴の作成 (`INSERT`)」と「在庫数の減算 (`UPDATE`)」という2つの更新処理を、明示的な `BEGIN TRANSACTION` ～ `COMMIT` ブロック内で実行しています。途中でエラーが発生した場合は即座に `ROLLBACK` されるため、在庫数と履歴の不整合（在庫はあるのに借りられない、等）は原理的に発生しません。

**実装コード (dvd_rental_app/app.py):**
```python
try:
    # トランザクション開始
    conn.execute('BEGIN TRANSACTION')
    
    # 1. レンタル履歴の挿入
    conn.execute('INSERT INTO rentals (user_id, dvd_id) VALUES (?, ?)', (user_id, dvd_id))
    
    # 2. 在庫数の減算
    conn.execute('UPDATE dvds SET stock_count = stock_count - 1 WHERE dvd_id = ?', (dvd_id,))
    
    # コミット（確定）
    conn.commit()
except Exception as e:
    # エラー時はロールバック
    conn.rollback()
```

**Q8. 在庫管理において、計算フィールドを使わず `stock_count` カラムを持たせた理由は？**
**A.** 参照頻度と更新頻度のバランスを考慮した結果です。店舗業務では「貸出可否の確認」という参照処理が圧倒的に多いため、都度 `rentals` テーブルを集計するコストを避け、値を保持する設計としました。更新時のロックコストはトランザクションで制御できており、読み取り性能を最大化する設計判断です。

**Q9. 削除処理における制約（ビジネスロジック）はどうなっていますか？**
**A.** 「貸出履歴が存在するユーザーや商品は削除できない」という制約を設けています。これは物理削除による過去データの欠損（参照整合性エラー）を防ぐためであり、会計上の記録としても履歴を完全に保持し続けるための仕様です。

**Q10. SQLite の動的型付けシステムに対して、型安全性はどう確保していますか？**
**A.** SQLite 自体は型に寛容ですが、`CREATE TABLE` 文で明示的に型 (`INTEGER`, `TEXT`, `DATE`) を定義し、アプリケーション側（Flask）でもバリデーションを行うことで、意図しないデータの混入を防いでいます。特に日付データは文字列形式（ISO 8601）で統一して管理しています。

**Q11. 貸出期間や延滞の判定ロジックはDB側・アプリ側のどちらにありますか？**
**A.** アプリケーション層のロジックと、SQLクエリの両方で判定可能です。画面表示用にはPythonの `datetime` で計算していますが、統計情報（延滞リストなど）の取得にはSQLiteの `julianday()` 関数を用いたSQLクエリを使用し、DB側で効率的にフィルタリングを行っています。

---

### Vector DB & AI検索

**Q12. なぜ `LIKE` 検索ではなく Vector DB を実装したのですか？**
**A.** 顧客のニーズは「泣ける映画」や「家族で楽しめる」といった、タイトルやあらすじに含まれない「概念」にあるからです。これらはキーワード一致（`LIKE`）では検索不可能であり、意味（セマンティック）をベクトル空間上の距離として計算できる Vector DB が必須機能でした。

**Q13. ベクトル化モデル `paraphrase-multilingual-MiniLM-L12-v2` の選定理由は？**
**A.** 日本語を含む多言語に対応しており、かつ軽量である点が決定打です。店舗のPCリソース（GPUなし）でも遅延なくベクトル変換・検索が可能であり、精度と速度のバランスが最も実用的であると判断しました。

**Q14. 384次元という次元数は、映画検索において十分ですか？**
**A.** はい、十分です。映画のあらすじやタイトルに含まれる意味情報は、数千次元の巨大モデルでなくとも384次元の空間で十分に分離・表現可能です。実際に「SF」と「恋愛」などのジャンル差や、「感動」といった感情の機微も適切に捉えられています。

**Q15. ハイブリッド検索（ベクトル＋キーワード補正）のアルゴリズム詳細は？**
**A.** まずベクトル検索でコサイン類似度が高い上位20件を候補として抽出します。その候補に対し、検索クエリがタイトルに含まれていればスコアに `+2.0`、説明文に含まれていれば `+1.0` を加算します。これにより、ベクトル検索の弱点である「固有名詞の完全一致」を補完し、ユーザーの明確な検索意図（例：「ジブリ」）を最優先する仕様としています。

**実装コード (dvd_rental_app/app.py):**
```python
# ハイブリッド検索ロジック
if query in title:
    score += 2.0 # タイトル一致で強力なブースト
elif query in desc:
    score += 1.0 # 説明文一致で中程度のブースト
```

**Q16. ベクトル化対象のテキストデータを「タイトル＋ジャンル＋説明文」とした意図は？**
**A.** 説明文だけでは文脈が不足する場合があるためです。例えば「SF」というジャンル名を含めることで、「宇宙」という単語がないSF作品でも、ジャンルのベクトル情報によって「宇宙」関連のクエリと高い類似度を持つようになります。メタデータをテキストに埋め込むことで、検索精度を底上げしています。

**Q17. ベクトルデータ（Embedding）はどのように保存されていますか？**
**A.** `dvd_vector.db` という独立した SQLite ファイルの `dvd_embeddings` テーブルに保存しています。384次元の `numpy.ndarray`（浮動小数点数配列）をバイナリ (`BLOB`) にシリアライズして格納しており、読み出し時にデシリアライズして計算に使用します。

**Q18. RDB と Vector DB を分離した理由と、整合性の担保方法は？**
**A.** 機能の疎結合化のためです。RDB は業務の基幹であり、Vector DB は検索補助機能です。分離することで、将来的に Vector DB のみ別エンジンに差し替えることも容易です。整合性については、DVD登録・更新時に必ず両方のDBを更新するフローをアプリケーション側で徹底することで担保しています。

**Q19. ベクトル検索のパフォーマンス（検索速度）についてどう考えていますか？**
**A.** 今回の規模（数千〜数万件）であれば、全件スキャンによるコサイン類似度計算でも数ミリ秒〜数十ミリ秒で完了するため、インメモリの `numpy` 計算で完全に実用的です。高価なインデックスサーバーを立てる必要がなく、シンプルかつ高速な構成です。

**Q20. このシステムにおける「AI」の役割定義は？**
**A.** 「人間の曖昧な記憶や感情」と「データベース上の商品」を橋渡しするインターフェースとしての役割です。単なるデータ検索ではなく、顧客の潜在的なニーズ（〜な気分の映画が見たい）を理解し、提案するコンシェルジュ機能を、Embedding技術によって低コストに実現しています。
