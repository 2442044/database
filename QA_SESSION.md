# 講義発表 Q&A 想定集
## 対象: データベースに精通した教授・技術者

---

### アーキテクチャ・技術選定

**Q1. なぜ Django ではなく Flask を採用したのですか？**
**A.** 今回の要件である「小規模な単一店舗の管理」に対し、Django は機能過多（Overkill）であり、学習コストと実装の軽快さを重視したため Flask を採用しました。Flask は最小限の機能からスタートでき、今回のように独自の Vector DB を組み込むといったカスタマイズもしやすいため、プロトタイピングに適していると判断しました。

**Q2. 本番環境でも SQLite を使い続けるつもりですか？**
**A.** 現在は小規模なプロトタイプのため、設定ファイル不要で可搬性の高い SQLite を採用しています。しかし、店舗数が増えたり同時アクセス数が増加した場合は、同時書き込み性能や堅牢性の観点から PostgreSQL への移行を想定しています。SQLAlchemy 等の ORM を導入すれば、コード変更を最小限に抑えて移行可能です。

**Q3. WebサーバーとAPサーバーの構成はどうなっていますか？**
**A.** 開発環境では Flask の内蔵サーバーを使用していますが、Docker 構成上では Nginx をリバースプロキシとして前段に置き、Gunicorn (WSGIサーバー) で Flask アプリケーションを動かす構成にしています。これにより、静的ファイルの配信効率化とセキュリティ向上を図っています。

---

### データベース設計 (RDB)

**Q4. データベースの正規化はどのレベルまで行っていますか？**
**A.** 第3正規形（3NF）まで適用しています。具体的には、`genres` テーブルを `dvds` から分離し、ジャンル名への依存を排除しました。これにより、ジャンル名の変更時も更新異常が発生せず、整合性が保たれます。

**Q5. 外部キー制約 (Foreign Key) は具体的にどこで、何のために使っていますか？**
**A.** `dvds.genre_id` が `genres.genre_id` を、`rentals.user_id` と `rentals.dvd_id` がそれぞれ `users` と `dvds` の主キーを参照しています。これにより、存在しないジャンルIDの登録や、削除されたユーザーIDでの貸出記録作成といった不整合をデータベースレベルで強制的に防いでいます (`ON DELETE RESTRICT` 相当の挙動)。

**Q6. インデックス設計について教えてください。**
**A.** 主キー（`INTEGER PRIMARY KEY`）には自動的にクラスター化インデックスが作成されます。加えて、`users` テーブルの `member_code` と `phone` に `UNIQUE` 制約を付与しており、これにより一意性制約のためのインデックスが作成されます。これらは会員検索時のクエリパフォーマンス向上にも寄与しています。

**Q7. 貸出・返却時の同時実行制御（排他制御）はどうしていますか？**
**A.** SQLite はデータベースファイル全体のロックを行いますが、アプリケーション側でも `BEGIN TRANSACTION` を明示的に発行し、一連の処理（レンタル記録の作成と在庫の減算）をアトミックに行っています。厳密な行ロックが必要な場合は PostgreSQL への移行が必要ですが、現状の規模感ではトランザクション処理で十分な整合性を担保できると考えています。

**Q8. `total_stock` と `stock_count` を分けた理由は？（計算フィールドではダメなのか）**
**A.** 貸出可能数 (`stock_count`) は頻繁に参照される値であり、毎回 `rentals` テーブルを集計（`COUNT`）して算出すると、データ量が増えた際にパフォーマンスのボトルネックになります。そのため、あえて値を保持する設計（マテリアライズドに近い考え方）を採用し、更新時のコストと引き換えに参照速度を優先しました。

**Q9. 物理削除と論理削除、どちらを採用していますか？**
**A.** 現状はシンプルさを優先して物理削除 (`DELETE`) を実装していますが、制約として「貸出履歴があるユーザー・商品は削除できない」というロジックをアプリケーション側で入れています。実運用を考えると、履歴保持のために `is_deleted` フラグを用いた論理削除への移行が望ましいと考えています。

**Q10. ユーザーの `birth_date` は何のために保持していますか？**
**A.** 年齢制限のある作品（R15+など）の貸出可否判断や、マーケティング分析（年代別レンタル傾向など）への活用を想定しています。

---

### Vector DB / AI検索

**Q11. なぜ SQL の `LIKE` 検索や全文検索エンジンではなく、Vector DB を採用したのですか？**
**A.** `LIKE` 検索では「泣ける」「家族向け」といった、タイトルや説明文に直接含まれない抽象的な概念（セマンティック）での検索が不可能だからです。ユーザーの曖昧なニーズに応えるには、言葉の意味をベクトル化して類似度を測るアプローチが不可欠でした。

**Q12. ベクトル化にはどのモデルを使用していますか？また、その理由は？**
**A.** `paraphrase-multilingual-MiniLM-L12-v2` を採用しました。理由は、軽量で高速に動作しつつ、日本語を含む多言語に対応しているためです。ローカル環境（CPUのみ）でも実用的な速度で推論が可能である点を評価しました。

**Q13. ベクトルの次元数はいくつですか？**
**A.** 384次元です。これは `MiniLM` モデルの仕様ですが、数千次元の大規模モデルと比較しても、今回の小規模なドメイン（映画検索）においては十分な表現力を持っています。

**Q14. ハイブリッド検索のロジックについて詳しく教えてください。**
**A.** まずベクトル検索で意味的に近い候補（Top 20）を取得し、その候補の中で「クエリのキーワードがタイトルに含まれていれば +2.0点」「説明文に含まれていれば +1.0点」というスコア加算を行っています。これにより、純粋なベクトル類似度だけでは低くなりうる「固有名詞の一致」を救い上げ、検索意図とのズレを補正しています。

**Q15. Vector DB として専用のミドルウェア（Pinecone, Milvus等）を使わなかったのはなぜですか？**
**A.** システム構成をシンプルに保つためです。数万件規模のデータであれば、SQLite に BLOB としてベクトルを保存し、オンメモリで `numpy` を使って計算する方式で十分な速度が出ます。外部サービスへの依存を減らし、Docker コンテナ単体で完結する設計を優先しました。

**Q16. ベクトルデータの更新タイミングはいつですか？**
**A.** 商品の新規登録 (`add_dvd`) および編集 (`edit_dvd`) のタイミングで、同期的にベクトル化処理を行い、DBを更新しています。大量データの一括登録が必要になった場合は、バックグラウンドジョブ（非同期処理）への切り出しを検討します。

**Q17. ベクトル化するテキストに「ジャンル名」を含めたのはなぜですか？**
**A.** 説明文だけでは文脈が不足する場合があるためです。例えば「SF」というジャンル名を含めることで、「宇宙」や「未来」といった単語が含まれていなくても、SF作品としての特徴をベクトル空間上で強調できます。これにより、「SF映画が見たい」というクエリに対する精度が向上しました。

---

### その他・将来性

**Q18. セキュリティ対策として、SQLインジェクション対策はどうなっていますか？**
**A.** Python の `sqlite3` モジュールのプレースホルダ (`?`) を使用したパラメータバインドを徹底しています。SQL文に文字列を直接埋め込むことはしていませんので、インジェクション攻撃のリスクは低減されています。

**Q19. 大規模化した場合、どこがボトルネックになりますか？**
**A.** 最初に限界が来るのは、ベクトル検索の計算部分（全件スキャン＋コサイン類似度計算）です。データが10万件を超えると線形探索では遅くなるため、Faiss や ChromaDB のような、近似最近傍探索（ANN）インデックスを持つ専用ライブラリへの移行が必要になります。

**Q20. このシステムをクラウド（AWS等）にデプロイする場合の構成案は？**
**A.** アプリケーションは AWS App Runner や ECS (Fargate) でコンテナ実行し、データベースは SQLite から Amazon RDS (PostgreSQL) に置き換えます。Vector DB については、RDS の `pgvector` 拡張機能を利用することで、RDB と Vector DB を単一のインスタンスで管理・結合でき、運用コストを抑えつつスケーラビリティを確保できると考えています。
